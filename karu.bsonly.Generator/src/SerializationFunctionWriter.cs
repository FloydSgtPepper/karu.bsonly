using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.ComponentModel;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading.Tasks;

namespace karu.bsonly.Generator
{


  public class SerializationFunctionWriter
  {
    public enum BsonType
    {
      BsonUtf8 = 0,
      BsonDouble = 1,
      BsonBool = 2,
      BsonInt32 = 3,
      BsonInt64 = 4,
      BsonGuid = 5,
      BsonNull = 6,
      BsonArray = 7,
      BsonBinary = 8,
      BsonDocument = 9
    }

    private static readonly string[] _WriteMethods = {
      "WriteString",
      "WriteDouble",
      "WriteBool",
      "WriteInt",
      "WriteLong",
      "WriteGuid",
      "WriteNull",
      "WriteArray",
      "WriteBinary",
      "WriteDocument"
    };

    private static readonly string[] _ReadMethods = {
      "ReadString",
      "ReadDouble",
      "ReadBool",
      "ReadInt",
      "ReadLong",
      "ReadGuid",
      "ReadNull",
      "ReadArray",
      "ReadBinary",
      "ReadDocument"
    };

    private static readonly string[] _TypeByte = {
      "global::karu.bsonly.Serialization.Interface.BsonConstants.BSON_TYPE_UTF8",
      "global::karu.bsonly.Serialization.Interface.BsonConstants.BSON_TYPE_DOUBLE",
      "global::karu.bsonly.Serialization.Interface.BsonConstants.BSON_TYPE_BOOL",
      "global::karu.bsonly.Serialization.Interface.BsonConstants.BSON_TYPE_INT32",
      "global::karu.bsonly.Serialization.Interface.BsonConstants.BSON_TYPE_INT64",
      "global::karu.bsonly.Serialization.Interface.BsonConstants.BSON_TYPE_BINARY", // Guid
      "global::karu.bsonly.Serialization.Interface.BsonConstants.BSON_TYPE_NULL",
      "global::karu.bsonly.Serialization.Interface.BsonConstants.BSON_TYPE_ARRAY",
      "global::karu.bsonly.Serialization.Interface.BsonConstants.BSON_TYPE_BINARY",
      "global::karu.bsonly.Serialization.Interface.BsonConstants.BSON_TYPE_DOCUMENT"
  };


    static public void WriteWrapSerializerClass(Model model, System.CodeDom.Compiler.IndentedTextWriter source)
    {
      source.WriteLine("");
      source.WriteLine("");
      source.WriteLine("namespace karu.bsonly.Serialization");
      source.WriteLine("{");

      source.WriteLine("static public partial class Serializer");
      source.WriteLine("{");
      source.Indent++;

      // writer
      source.WriteLine($"public static void Serialize(karu.bsonly.Interface.IBasicSerializer serializer, ReadOnlySpan<byte> key,{model.WrappedClass} value)");
      source.WriteLine("{");
      source.Indent++;
      source.WriteLine($"var wrapped_value = new {model.ClassName}(value);");
      source.WriteLine($"Serializer.Serialize(serializer, key, wrapped_value);");
      source.Indent--;
      source.WriteLine("}");

      // reader
      source.WriteLine("");
      source.WriteLine($"public static void Serialize(karu.bsonly.Interface.IBasicDeserializer deserializer, ReadOnlySpan<byte> key, {model.WrappedClass} value)");
      source.WriteLine("{");
      source.Indent++;
      source.WriteLine($"var wrapped_value = new {model.ClassName}(value);");
      source.WriteLine($"Serializer.Serialize(deserializer, key, wrapped_value);");
      source.WriteLine($"wrapped_value.SetWrappedClassValues(value);");
      source.Indent--;
      source.WriteLine("}");

      source.Indent--;
      source.WriteLine("}");
      source.WriteLine("}");
    }

    static public void WriteIntro(Model model, System.CodeDom.Compiler.IndentedTextWriter source)
    {
      source.WriteLine("// <auto-generated/>");
      source.WriteLine("#nullable enable");
      source.WriteLine("");
      // source.WriteLine("using karu.bsonly.Serialization;");
      // source.WriteLine("using karu.bsonly.Interface;");
      // source.WriteLine("");

      if (model.Namespace != string.Empty)
      {
        source.WriteLine($"namespace {model.Namespace}");
        source.WriteLine("{");
        // no indentation after namespace
      }

      source.WriteLine($"partial class {model.ClassName} : global::karu.bsonly.Serialization.Interface.ISerializable");
      source.WriteLine("{");
      source.Indent++;
    }

    static public void WriteClassEnd(Model model, System.CodeDom.Compiler.IndentedTextWriter source)
    {
      source.Indent--;
      source.WriteLine("} // class");
    }

    static public void WriteOuttro(Model model, System.CodeDom.Compiler.IndentedTextWriter source)
    {
      if (model.Namespace != string.Empty)
        source.WriteLine("} // namespace");
    }


    static public void WriteSerializeToBson(Model model, System.CodeDom.Compiler.IndentedTextWriter source)
    {
      source.WriteLine($"public void Serialize(global::karu.bsonly.Serialization.Interface.IDocumentSerializer _generated_param_writer)");
      source.WriteLine("{");
      source.Indent++;

      var count = 0;
      var idx = 0;
      while (idx < model.Properties.Length())
      {
        BsonType bson_type;
        string cast = string.Empty;
        var prop = model.Properties.GetValue(idx);
        ++idx;

        if (prop.Order == Property.IGNORE_VALUE)
        {
          source.WriteLine($"// ignored: property {prop.Name} / {prop.BsonName} type:{prop.BsonType}");
          continue;
        }

        if (prop.BsonType == "Utf8")
          bson_type = BsonType.BsonUtf8;
        else
          (bson_type, cast) = GetBsonType(prop.Type);
        switch (bson_type)
        {
          case BsonType.BsonUtf8:
            if (cast == "Utf8")
            {
              source.WriteLine($"var _generated_tmp_{count} = System.Text.Encoding.UTF8.GetBytes(this.{prop.Name});");
              source.WriteLine($"_generated_param_writer.{_WriteMethods[(int)bson_type]}({prop.BsonName}u8).{_WriteMethods[(int)bson_type]}( _generated_tmp_{count});");
              ++count;
            }
            else
            {
              source.WriteLine($"_generated_param_writer.{_WriteMethods[(int)bson_type]}({prop.BsonName}u8).{_WriteMethods[(int)bson_type]}(this.{prop.Name});");
            }
            break;

          case BsonType.BsonBool:
          case BsonType.BsonInt32:
          case BsonType.BsonInt64:
          case BsonType.BsonDouble:
          case BsonType.BsonGuid:
          case BsonType.BsonNull:
            if (cast == string.Empty)
              source.WriteLine($"_generated_param_writer.{_WriteMethods[(int)bson_type]}({prop.BsonName}u8).{_WriteMethods[(int)bson_type]}(this.{prop.Name});");
            else
              source.WriteLine($"_generated_param_writer.{_WriteMethods[(int)bson_type]}({prop.BsonName}u8).{_WriteMethods[(int)bson_type]}(({cast})this.{prop.Name});");
            break;
          case BsonType.BsonDocument:
            source.WriteLine($"global::karu.bsonly.Serialization.Serializer.Serialize(_generated_param_writer, {prop.BsonName}u8, this.{prop.Name}); // {prop.Type} {prop.BsonType}");
            break;
          case BsonType.BsonArray:
            break;
          case BsonType.BsonBinary:
            break;

        }
      }

      source.Indent--;
      source.WriteLine("}");
    }

    static public void WriteSerializeFromBson(Model model, System.CodeDom.Compiler.IndentedTextWriter source)
    {
      int count = 0;
      source.WriteLine("");
      source.WriteLine($"public void Deserialize(global::karu.bsonly.Serialization.Interface.IDocumentDeserializer _generated_param_reader)");
      source.WriteLine("{");
      source.Indent++;

      var idx = 0;
      while (idx < model.Properties.Length())
      {
        BsonType bson_type;
        var cast = string.Empty;
        var prop = model.Properties.GetValue(idx);
        ++idx;
        if (prop.Order == Property.IGNORE_VALUE)
        {
          source.WriteLine($"// ignored: property {prop.Name} / {prop.BsonName} type:{prop.BsonType}");
          continue;
        }

        if (prop.BsonType == "Utf8")
        {
          bson_type = BsonType.BsonUtf8;
          cast = string.Empty;
        }
        else
          (bson_type, cast) = GetBsonType(prop.Type); // TODO: set the "default" casts in prop.BsonType

        // ISSUE: what exactly do I want here??
        // sth like:
        // member type: ushort -> serialize as int64 -> BsonType int64
        // if I can think of how: member type "hex string" -> BsonType vector<byte>

        // if (prop.BsonType != string.Empty)
        //  cast = prop.BsonType;


        var bson_type_byte = _TypeByte[(int)bson_type];
        switch (bson_type)
        {
          case BsonType.BsonUtf8:
            source.WriteLine($"if (_generated_param_reader.HasEntry({prop.BsonName}u8, {bson_type_byte}))");
            if (cast == "Utf8")
            {
              source.WriteLine("{");
              source.Indent++;
              source.WriteLine($"var _generated_tmp_{count} = _generated_param_reader.{_ReadMethods[(int)bson_type]}(); // order: {prop.Order} type: {prop.BsonType}");
              source.WriteLine($"this.{prop.Name} = System.Text.Encoding.UTF8.GetString(_generated_tmp_{count});");
              source.Indent--;
              source.WriteLine("}");
              ++count;
            }
            else
            {
              source.Indent++;
              source.WriteLine($"this.{prop.Name} = _generated_param_reader.{_ReadMethods[(int)bson_type]}().ToArray(); // order: {prop.Order} type: {prop.BsonType}");
              source.Indent--;

            }
            break;
          case BsonType.BsonBool:
          case BsonType.BsonInt32:
          case BsonType.BsonInt64:
          case BsonType.BsonDouble:
          case BsonType.BsonGuid:
          case BsonType.BsonNull:
            source.WriteLine($"if (_generated_param_reader.HasEntry({prop.BsonName}u8, {bson_type_byte}))");
            if (cast == string.Empty)
            {
              source.Indent++;
              source.WriteLine($"this.{prop.Name} = _generated_param_reader.{_ReadMethods[(int)bson_type]}(); // order: {prop.Order} type: {prop.BsonType}");
              source.Indent--;
            }
            else
            {
              source.WriteLine("{");
              source.Indent++;
              source.WriteLine($"var _generated_tmp_{count} = _generated_param_reader.{_ReadMethods[(int)bson_type]}(); // order: {prop.Order} type: {prop.BsonType}");
              source.WriteLine($"this.{prop.Name} = ({prop.Type})_generated_tmp_{count};");
              source.Indent--;
              source.WriteLine("}");
              count++;
            }
            break;
          case BsonType.BsonDocument:
            source.WriteLine($"if (_generated_param_reader.HasEntry({prop.BsonName}u8, {bson_type_byte}))");
            source.Indent++;
            source.WriteLine($"global::karu.bsonly.Serialization.Serializer.Serialize(_generated_param_reader, {prop.BsonName}u8, this.{prop.Name});");
            source.Indent--;
            break;
          case BsonType.BsonBinary:
            if (prop.SerializationMethod != string.Empty)
              if (!prop.SerializationMethod.Contains("."))
                source.WriteLine($"global::karu.bsonly.Serialization.Serializer.{prop.SerializationMethod}(_generated_param_reader, {prop.BsonName}u8, out this.{prop.Name});");
              else
                source.WriteLine($"{prop.SerializationMethod}(_generated_param_reader, {prop.BsonName}u8, out this.{prop.Name});");
            else
            {
              source.WriteLine($"if (_generated_param_reader.HasEntry({prop.BsonName}u8, {bson_type_byte}))");
              source.Indent++;
              source.WriteLine($"global::karu.bsonly.Serialization.Serializer.Serialize(_generated_param_reader, {prop.BsonName}u8, this.{prop.Name});");
              source.Indent--;
            }
            break;
          case BsonType.BsonArray:
            break;
        }
      }

      source.Indent--;
      source.WriteLine("}");
    }

    private static (SerializationFunctionWriter.BsonType, string cast_type) GetBsonType(string type_string)
    {
      var bson_type = (SerializationFunctionWriter.BsonType.BsonDocument, string.Empty);
      bson_type = type_string switch
      {
        "float" => (SerializationFunctionWriter.BsonType.BsonDouble, "double"),
        "double" => (SerializationFunctionWriter.BsonType.BsonDouble, string.Empty),
        "bool" => (SerializationFunctionWriter.BsonType.BsonBool, string.Empty),
        "sbyte" => (SerializationFunctionWriter.BsonType.BsonInt32, "int"),
        "byte" => (SerializationFunctionWriter.BsonType.BsonInt32, "int"),
        "char" => (SerializationFunctionWriter.BsonType.BsonInt32, "int"),
        "short" => (SerializationFunctionWriter.BsonType.BsonInt32, "int"),
        "int" => (SerializationFunctionWriter.BsonType.BsonInt32, string.Empty),
        "long" => (SerializationFunctionWriter.BsonType.BsonInt64, string.Empty),
        "uchar" => (SerializationFunctionWriter.BsonType.BsonInt32, "int"),
        "ushort" => (SerializationFunctionWriter.BsonType.BsonInt32, "int"),
        "uint" => (SerializationFunctionWriter.BsonType.BsonInt32, "int"),
        "ulong" => (SerializationFunctionWriter.BsonType.BsonInt64, "long"),
        "string" => (SerializationFunctionWriter.BsonType.BsonUtf8, "Utf8"),
        "Guid" => (SerializationFunctionWriter.BsonType.BsonGuid, string.Empty),
        "byte[]" => (SerializationFunctionWriter.BsonType.BsonBinary, string.Empty),
        "binary" => (SerializationFunctionWriter.BsonType.BsonBinary, string.Empty),
        // FIXME: proper handling of nullability needed
        "string?" => (SerializationFunctionWriter.BsonType.BsonUtf8, "Utf8"),
        "Guid?" => (SerializationFunctionWriter.BsonType.BsonGuid, string.Empty),
        "byte[]?" => (SerializationFunctionWriter.BsonType.BsonBinary, string.Empty),

        _ => (SerializationFunctionWriter.BsonType.BsonDocument, string.Empty),
      };

      return bson_type;
    }
  }
}


#region Copyright notice and license

// Copyright 2025 The bsonly Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#endregion